#!/bin/sh
#
# PART: Partition name
# START: Partition start address
# END: Partition end address
# SIZE: Partition size(in 1k block)
# MTD MAPPING: MTD mapping by the kernel so partitions can be read/written from/to with correct start addresses and size
# MTD DEVICE: MTD DEVIVE name that has been mapped by the kernel and can perform read/write operations
#
# Used partition names are the as mtdparts parameter on the kernel
#
#---------- T20 stock ----------
#PART     SIZE(dec)  START(dec)  START(hex)     MTD MAPPING               MTD DEVICE
#boot     256        0           0x0            256K@0(boot)              /dev/mtd0
#kernel   2048       256         0x40000        2048K@256K(t20_kernel)    /dev/mtd1
#root     3392       2304        0x240000       3392K@2304K(t20_root)     /dev/mtd2
#driver   640        5696        0x590000       640K@5696K(t20_driver)    /dev/mtd3
#appfs    4736       6336        0x630000       4736K@6336K(t20_apps)     /dev/mtd4
#backupk  2048       11072       0xad0000       2048K@11072K(t20_backupk) /dev/mtd5
#backupd  640        13120       0xcd0000       640K@13120K(t20_backupd)  /dev/mtd6
#backupa  2048       13760       0xd70000       2048K@13760K(t20_backupa) /dev/mtd7
#config   256        15808       0xf70000       256K@15808K(t20_config)   /dev/mtd8
#para     256        16064       0xfb0000       256K@16064K(t20_para)     /dev/mtd9
#
#---------- T31 stock ----------
#PART    SIZE(dec)  START(dec)  START(hex)     MTD MAPPING                MTD DEVICE
#boot    256        0           0x0            256K@0(boot)               /dev/mtd0
#kernel  1984       256         0x40000        1984K@256K(t31_kernel)     /dev/mtd10
#rootfs  3904       2240        0x230000       3904K@2240K(t31_rootfs)    /dev/mtd11
#app     3904       6144        0x600000       3904K@6144K(t31_app)       /dev/mtd12
#kback   1984       10048       0x9d0000       1984K@10048K(t31_kback)    /dev/mtd13
#aback   3904       12032       0xbc0000       3904K@12032K(t31_aback)    /dev/mtd14
#cfg     384        15936       0xf90000       384K@15936K(t31_cfg)       /dev/mtd15
#para    64         16320       0xff0000       64K@16320K(t31_para)       /dev/mtd16
#
#---------- T20 and T31 OpenIPC ----------
#PART         SIZE(dec)  START(dec)  START(hex) MTD MAPPING                       MTD DEVICE
#boot         256        0           0x0        256K@0(boot)                      /dev/mtd0
#env          64         256         0x40000    64K@256K(openipc_env)             /dev/mtd17
#kernel       3072       320         0x50000    3072K@320K(openipc_kernel)        /dev/mtd18
#rootfs       10240      3392        0x350000   10240K@3392K(openipc_rootfs)      /dev/mtd19
#rootfs-data  2752       13632       0xd50000   2752K@13632K(openipc_rootfs-data) /dev/mtd20
#
#Full flash mapping                            2752K@13632K,16384k@0(all)         /dev/mtd21
#
# MTD mapping with kernel commandline:
# CONFIG_CMDLINE="console=ttyS1,115200n8 mem=100M@0x0 rmem=28M@0x5000000 rdinit=/init mtdparts=jz_sfc:256K@0(boot),2048K@256K(t20_kernel),3392K@2304K(t20_root),640K@5696K(t20_driver),4736K@6336K(t20_apps),2048K@11072K(t20_backupk),640K@13120K(t20_backupd),2048K@13760K(t20_backupa),256K@15808K(t20_config),256K@16064K(t20_parcaa),1984K@256K(t31_kernel),3904K@2240K(t31_rootfs),3904K@6144K(t31_app),1984K@10048K(t31_kback),3904K@12032K(t31_aback),384K@15936K(t31_cfg),64K@16320K(t31_para),64K@256K(openipc_env),3072K@320K(openipc_kernel),10240K@3392K(openipc_rootfs),2752K@13632K(openipc_rootfs-data),16384k@0(all)"
#
#

exec > /tmp/initramfs.log 2>&1


mount -t devtmpfs devtmpfs /dev
mount -t proc proc /proc
mount -t sysfs sysfs /sys

sleep 1


function msg() {
# Descritpion: Allow output messages to be both displayed serial terminal and written on log file
	message="$1"
	echo "$message"
	echo "$message" > /dev/console
}

function msg_nonewline() {
	message="$1"
	echo -n "$message"
	echo -n "$message" > /dev/console
}

function initialize_t20_gpio_sdcard() {
# Description: T20 cameras need this to get SD card detected
	echo 43 > /sys/class/gpio/export
	echo in > /sys/class/gpio/gpio43/direction
	sleep 3 # Required delay for SD card init on T20
}

function initialize_gpio_leds() {
# Description: Export LEDs GPIO pins if they don't exist
	if [ ! -d /sys/class/gpio/gpio38 ]; then
		echo 38 > /sys/class/gpio/export
		echo out > /sys/class/gpio/gpio38/direction
		echo 1 > /sys/class/gpio/gpio38/value
	fi

	if [ ! -d /sys/class/gpio/gpio39 ]; then
		echo 39 > /sys/class/gpio/export
		echo out > /sys/class/gpio/gpio39/direction
		echo 1 > /sys/class/gpio/gpio39/value
	fi
}

function get_t20_stock_partmtd() {
# Description: Return MTD device of a given partition name on T20 cameras stock firmware
# Syntax: get_t20_stock_partmtd <partname>
	case "$1" in
		"boot")
			echo -n "/dev/mtd0" ;;
		"kernel")
			echo -n "/dev/mtd1" ;;
		"root")
			echo -n "/dev/mtd2" ;;
		"driver")
			echo -n "/dev/mtd3" ;;
		"appfs")
			echo -n "/dev/mtd4" ;;
		"backupk")
			echo -n "/dev/mtd5" ;;
		"backupd")
			echo -n "/dev/mtd6" ;;
		"backupa")
			echo -n "/dev/mtd7" ;;
		"config")
			echo -n "/dev/mtd8" ;;
		"para")
			echo -n "/dev/mtd9" ;;
	esac
}

function get_t31_stock_partmtd() {
# Description: Return MTD device of a given partition name on T31 cameras stock firmware
# Syntax: get_t31_stock_partmtd <partname>
	case "$1" in
		"boot")
			echo -n "/dev/mtd0" ;;
		"kernel")
			echo -n "/dev/mtd10" ;;
		"rootfs")
			echo -n "/dev/mtd11" ;;
		"app")
			echo -n "/dev/mtd12" ;;
		"kback")
			echo -n "/dev/mtd13" ;;
		"aback")
			echo -n "/dev/mtd14" ;;
		"cfg")
			echo -n "/dev/mtd15" ;;
		"para")
			echo -n "/dev/mtd16" ;;
	esac
}

function get_openipc_partmtd() {
# Description: Return MTD device of a given partition name on OpenIPC firmware
# Syntax: get_openipc_partmtd <partname>
	case "$1" in
		"boot")
			echo -n "/dev/mtd0" ;;
		"env")
			echo -n "/dev/mtd17" ;;
		"kernel")
			echo -n "/dev/mtd18" ;;
		"rootfs")
			echo -n "/dev/mtd19" ;;
		"rootfs-data")
			echo -n "/dev/mtd20" ;;
	esac
}

function get_t20_stock_partimgfile() {
# Description: Return filename for the partition used for backup/restore of a given partition name on T20 stock firmware
# Syntax: get_t20_stock_partimgfile <partname>
	case "$1" in
		"boot")
			echo -n "t20_stock_boot.bin" ;;
		"kernel")
			echo -n "t20_stock_kernel.bin" ;;
		"root")
			echo -n "t20_stock_root.bin" ;;
		"driver")
			echo -n "t20_stock_driver.bin" ;;
		"appfs")
			echo -n "t20_stock_appfs.bin" ;;
		"backupk")
			echo -n "t20_stock_backupk.bin" ;;
		"backupd")
			echo -n "t20_stock_backupd.bin" ;;
		"backupa")
			echo -n "t20_stock_backupa.bin" ;;
		"config")
			echo -n "t20_stock_config.bin" ;;
		"para")
			echo -n "t20_stock_para.bin" ;;
	esac
}

function get_t31_stock_partimgfile() {
# Description: Return filename for the partition used for backup/restore of a given partition name on T31 stock firmware
# Syntax: get_t31_stock_partimgfile <partname>
	case "$1" in
		"kernel")
			echo -n "t31_stock_kernel.bin" ;;
		"rootfs")
			echo -n "t31_stock_rootfs.bin" ;;
		"app")
			echo -n "t31_stock_app.bin" ;;
		"kback")
			echo -n "t31_stock_kback.bin" ;;
		"aback")
			echo -n "t31_stock_aback.bin" ;;
		"cfg")
			echo -n "t31_stock_cfg.bin" ;;
		"para")
			echo -n "t31_stock_para.bin" ;;
	esac
}

function get_openipc_partimgfile() {
# Description: Return filename for the partition used for backup/restore of a given partition name on OpenIPC firmware
# Syntax: get_openipc_partimgfile <partname>
	case "$1" in
		"boot")
			echo -n "openipc_boot.bin" ;;
		"env")
			echo -n "openipc_env.bin" ;;
		"kernel")
			echo -n "openipc_kernel.bin" ;;
		"rootfs")
			echo -n "openipc_rootfs.bin" ;;
		"rootfs-data")
			echo -n "openipc_rootfs-data.bin" ;;
	esac
}

function get_t20_stock_restore_opt_value() {
# Description: Return user option to decide if a given partition is restored or not on T20 stock firmware
# Syntax: get_t20_stock_restore_opt_value <partname>
	case "$1" in
		"boot")
			echo -n "$t20_restore_boot" ;;
		"kernel")
			echo -n "$t20_restore_kernel" ;;
		"root")
			echo -n "$t20_restore_root" ;;
		"driver")
			echo -n "$t20_restore_driver" ;;
		"appfs")
			echo -n "$t20_restore_appfs" ;;
		"backupk")
			echo -n "$t20_restore_backupk" ;;
		"backupd")
			echo -n "$t20_restore_backupd" ;;
		"backupa")
			echo -n "$t20_restore_backupa" ;;
		"config")
			echo -n "$t20_restore_config" ;;
		"para")
			echo -n "$t20_restore_para" ;;
	esac
}

function get_t31_stock_restore_opt_value() {
# Description: Return user option to decide if a given partition is restored or not on T31 stock firmware
# Syntax: get_t31_stock_restore_opt_value <partname>
	case "$1" in
		"kernel")
			echo -n "$t31_restore_kernel" ;;
		"rootfs")
			echo -n "$t31_restore_rootfs" ;;
		"app")
			echo -n "$t31_restore_app" ;;
		"kback")
			echo -n "$t31_restore_kback" ;;
		"aback")
			echo -n "$t31_restore_aback" ;;
		"cfg")
			echo -n "$t31_restore_cfg" ;;
		"para")
			echo -n "$t31_restore_para" ;;
	esac
}

function get_openipc_restore_opt_value() {
# Description: Return user option to decide if a given partition is restored or not on OpenIPC firmware
# Syntax: get_openipc_restore_opt_value <partname>
	case "$1" in
		"boot")
			echo -n "$openipc_restore_boot" ;;
		"env")
			echo -n "$openipc_restore_env" ;;
		"kernel")
			echo -n "$openipc_restore_kernel" ;;
		"rootfs")
			echo -n "$openipc_restore_rootfs" ;;
		"rootfs-data")
			echo -n "$openipc_restore_rootfs_data" ;;
	esac
}

function restore_file_to_partition() {
# Description: Restore partition from <infile> to <partmtd>
# Syntax: restore_file_to_partition <partname> <infile> <partname>
	local partname="$1"
	local infile="$2"
	local partmtd="$3"

	[ ! -f $infile ] && { msg " + $infile is missing" ; return 1 ; }
	
	msg " + Restoring $partname partition"
	if [[ "$dry_run" == "yes" ]]; then
		msg_nonewline " + Checking md5 of $infile: "
		md5sum -c $infile.md5sum && msg " + (this command is not run) flashcp $infile $partmtd"
	else
		msg_nonewline " + Checking md5 of $infile: "
		md5sum -c $infile.md5sum && flashcp $infile $partmtd || { msg " + md5 checksum for $infile failed" ; return 1 ; }
	fi
}

function backup_partition_to_file() {
# Description: Backup partition <partmtd> to <outfile>
# Syntax: backup_partition_to_file <partname> <partmtd> <outfile>
	local partname="$1"
	local partmtd="$2"
	local outfile="$3"
	
	[ -f $outfile ] && { msg " + $outfile exists" ; return 1 ; }

	msg " + Making backup for $partname partition"	
	if [[ "$dry_run" == "yes" ]]; then
		msg " + (this command is not run) flashcp $partmtd $outfile"
		msg " + (this command is not run) md5sum $outfile > $outfile.md5sum"
	else
		flashcp $partmtd $outfile || { msg " + Failed to back up $partname partition" ; return 1 ; }
		md5sum $outfile > $outfile.md5sum
	fi

}

function backup_full_flash() {
	case "$current_fw_type" in
		"stock")
			flashcp $concat_mtddev $stock_backup_dir_path/$stock_full_flash_filename
			md5sum $stock_backup_dir_path/$stock_full_flash_filename > $stock_backup_dir_path/$stock_full_flash_filename.md5sum
			;;
		"openipc")
			flashcp $concat_mtddev $openipc_backup_dir_path/$openipc_full_flash_filename
			md5sum $openipc_backup_dir_path/$openipc_full_flash_filename > $openipc_backup_dir_path/$openipc_full_flash_filename.md5sum
			;;
	esac
}

function backup_t20_stock_parts() {
# Description: Create partition images of all stock partitions on T20 flash chip
	msg "Executing backup_t20_stock_parts"
	
	for partname in $t20_stock_partname_list; do
		local partmtd=$(get_t20_stock_partmtd $partname)
		local outfile_name=$(get_t20_stock_partimgfile $partname)
		local outfile=$stock_backup_dir_path/$outfile_name
		msg "- Backup: $partname to file $outfile ---"
		backup_partition_to_file $partname $partmtd $outfile || { msg "Backup $partname partition to $outfile failed" ; exit_init ; }
	done
}

function backup_t20_stock_config() {
# Description: Create tar.gz archive for config partition on T20 flash chip
	msg "Creating archive file for files on config partition on T20 camera"
	
	mkdir /t20_stock_config
	t20_config_partmtd=$(get_t20_stock_partmtd "config")
	mount -t jffs2 $t20_config_partmtd /t20_stock_config
	tar -cvf $stock_backup_dir_path/config.tar.gz /t20_stock_config
	sync
	umount /t20_stock_config && rmdir /t20_stock_config
}

function backup_t20_stock_para() {
# Description: Create tar.gz archive for para partition on T20 flash chip
	msg "Creating archive file for files on para partition on T20 camera"
	
	mkdir /t20_stock_para
	t20_config_partmtd=$(get_t20_stock_partmtd "para")
	mount -t jffs2 $t20_para_partmtd /t20_stock_para
	tar -cvf $stock_backup_dir_path/para.tar.gz /t20_stock_para
	sync
	umount /t20_stock_para && rmdir /t20_stock_para
}

function backup_t31_stock_parts() {
# Description: Create partition images of all stock partitions on T31 flash chip
	msg "Executing backup_t31_stock_parts"
	
	for partname in $t31_stock_partname_list; do
		local partmtd=$(get_t31_stock_partmtd $partname)
		local outfile_name=$(get_t31_stock_partimgfile $partname)
		local outfile=$stock_backup_dir_path/$outfile_name
		msg "- Backup: $partname to file $outfile ---"
		backup_partition_to_file $partname $partmtd $outfile || { msg "Backup $partname partition to $outfile failed" ; exit_init ; }
	done
}

function backup_t31_stock_config() {
# Description: Create tar.gz archive for config partition on T31 flash chip
	msg "Creating archive file for files on config partition on T31 camera"
	
	mkdir /t31_stock_config
	t31_config_partmtd=$(get_t31_stock_partmtd "cfg")
	mount -t jffs2 $t31_config_partmtd /t31_stock_config
	tar -cvf $stock_backup_dir_path/configs.tar.gz /t31_stock_config
	sync
	umount /t31_stock_config && rmdir /t31_stock_config
}

function backup_openipc_parts() {
# Description: Create partition images of all OpenIPC partitions on T31 flash chip
	msg "Executing backup_openipc_parts"
	
	for partname in $openipc_partname_list; do
		local partmtd=$(get_openipc_partmtd $partname)
		local outfile_name=$(get_openipc_partimgfile $partname)
		local outfile=$openipc_backup_dir_path/$outfile_name
		msg "- Backup: $partname to file $outfile ---"
		backup_partition_to_file $partname $partmtd $outfile || { msg "Backup $partname partition to $outfile failed" ; exit_init ; }
	done
}

function restore_t20_stock_parts() {
# Description: Restore stock partitions from partition images on T20 flash chip
	msg "Executing backup_t31_stock_parts"

	for partname in $t20_stock_partname_list; do
		local infile_name=$(get_t20_stock_partimgfile $partname)
		local infile=$stock_restore_dir_path/$infile_name
		local partmtd=$(get_t20_stock_partmtd $partname)
		local restore_opt_value=$(get_t20_stock_restore_opt_value $partname)

		msg "- Restore: $partname from file $infile"
		if [[ "$restore_opt_value" == "yes" ]]; then
			msg " + t20_restore_$partname value is Yes"
			restore_file_to_partition $partname $infile $partmtd || { msg "Restore $infile to $partname partition failed" ; exit_init ; }
		else
			msg " + t20_restore_$partname value is No"
		fi
	done
}

function restore_t31_stock_parts() {
# Description: Restore stock partitions from partition images on T31 flash chip
	msg "Executing backup_t31_stock_parts"
	
	for partname in $t31_stock_partname_list; do
		local infile_name=$(get_t31_stock_partimgfile $partname)
		local infile=$stock_restore_dir_path/$infile_name
		local partmtd=$(get_t31_stock_partmtd $partname)
		local restore_opt_value=$(get_t31_stock_restore_opt_value $partname)

		msg "- Restore: $partname from file $infile"
		if [[ "$restore_opt_value" == "yes" ]]; then
			msg " + t31_restore_$partname value is Yes"
			restore_file_to_partition $partname $infile $partmtd || { msg "Restore $infile to $partname partition failed" ; exit_init ; }
		else
			msg " + t31_restore_$partname value is No"
		fi
	done
}

function restore_openipc_parts() {
# Description: Restore OpenIPC partitions from partition images on T20 flash chip
	msg "Executing restore_openipc_parts"

	for partname in $openipc_partname_list; do
		local infile_name=$(get_openipc_partimgfile $partname)
		local infile=$openipc_restore_dir_path/$infile_name
		local partmtd=$(get_openipc_partmtd $partname)
		local restore_opt_value=$(get_openipc_restore_opt_value $partname)

		msg "- Restore: $partname from file $infile"
		if [[ "$restore_opt_value" == "yes" ]]; then
			msg " + openipc_restore_$partname value is Yes"
			restore_file_to_partition $partname $infile $partmtd || { msg "Restore $infile to $partname partition failed" ; exit_init ; }
		else
			msg " + openipc_restore_$partname value is No"
		fi
	done
}

function move_continue_boot_img_file() {
# Description: Rename SD card boot image to avoid infinite boot loop and remane SD card boot image to be booted next boot
	if [[ "$enable_continue_boot_img" == "yes" ]]; then
		echo "enable_continue_boot_img value is Yes"
		case "$current_fw_type" in
			"stock")
				msg "Renaming /sdcard/$continue_boot_img_filename to /sdcard/factory_t31_ZMC6tiIDQN"
				mv /sdcard/$continue_boot_img_filename /sdcard/factory_t31_ZMC6tiIDQN
				;;
			"openipc")
				msg "Renaming /sdcard/$continue_boot_img_filename to /sdcard/factory_0P3N1PC_kernel"
				mv /sdcard/$continue_boot_img_filename /sdcard/factory_0P3N1PC_kernel
				;;
		esac
	else
		echo "enable_continue_boot_img value is No"
	fi
}

function move_flash_tool_boot_img_file() {
	case "$current_fw_type" in
		"stock")
			msg "Renaming /sdcard/factory_t31_ZMC6tiIDQN to /sdcard/factory_t31_ZMC6tiIDQN.$installer_name"
			mv /sdcard/factory_t31_ZMC6tiIDQN /sdcard/factory_t31_ZMC6tiIDQN.$installer_name
			;;
		"openipc")
			msg "Renaming /sdcard/factory_0P3N1PC_kernel to /sdcard/factory_0P3N1PC_kernel.$installer_name"
			mv /sdcard/factory_0P3N1PC_kernel /sdcard/factory_0P3N1PC_kernel.$installer_name
			;;
	esac
}

function exit_init() {
# Move initramfs log to SD card and reboot
	move_continue_boot_img_file
	move_flash_tool_boot_img_file
	msg "Initramfs init is finished! Exiting now"
	[ -f /tmp/initramfs.log ] && cp /tmp/initramfs.log $log_file
	[ -f /tmp/initramfs_missing-config-file.log ] && cp /tmp/initramfs_missing-config-file.log $log_file_fallback
	sync
	umount /sdcard
	sleep 1
	reboot
}

function set_vaviables() {
	installer_name="wz_flash-helper"

	stock_backup_dir_path="/sdcard/Wyze_factory_backup/"
	openipc_backup_dir_path="/sdcard/wz_flash-helper/backup/openipc"

	stock_full_flash_filename="stock_fullflash"
	openipc_full_flash_filename="openipc_fullflash"
	
	stock_restore_dir_path="/sdcard/wz_flash-helper/restore/stock"
	openipc_restore_dir_path="/sdcard/wz_flash-helper/restore/openipc"

	config_file="/sdcard/wz_flash-helper/wz_flash-helper.conf"
	log_file="/sdcard/wz_flash-helper/wz_flash-helper.log"
	log_file_fallback="/sdcard/wz_flash-helper_no-config-error.log"

	t20_stock_partname_list="boot kernel root driver appfs backupk backupd backupa config para"
	t31_stock_partname_list="boot kernel rootfs app kback aback config para"
	openipc_partname_list="boot env kernel rootfs rootfs-data"

	concat_mtddev="/dev/mtd21"
	stock_full_flash_filename="stock_all.bin"
	openipc_full_flash_filename="openipc_all.bin"

	boot_mtdblockdev="/dev/mtdblock0"
}

function detect_chip_and_fw() {
# Description: Detect chip family and current firmware to do later operations correctly
	chip_name=`ipcinfo-mips32 --chip-name`
	chip_family=`ipcinfo-mips32 --family`
	msg "Detected chip name: $chip_name, chip family: $chip_family"

	dd if=$boot_mtdblockdev of=/tmp/uboot_partimg
	strings /tmp/uboot_partimg > /tmp/uboot_partimg_strings

	if grep -q "demo.bin" /tmp/uboot_partimg_strings; then #  Cam v2 & Cam Pan
	   	msg "Camera is currently on Cam Pan v2 or Cam Pan stock firmware"
	   	current_fw_type="stock"

	elif grep -q "demo_wcv3.bin" /tmp/uboot_partimg_strings; then # Cam v3
	   	msg "Camera is currently on Cam v3 stock firmware"
	   	current_fw_type="stock"

	elif grep -q "recovery_wcpv2.bin" /tmp/uboot_partimg_strings ; then # Cam Pan v2
	   	msg "Camera is currently on Cam Pan v2 stock firmware"
	   	current_fw_type="stock"

	elif grep -q "factory_0P3N1PC_kernel" /tmp/uboot_partimg_strings ; then
	   	msg "Camera is currently on OpenIPC firmware"
		current_fw_type="openipc"

	else
		{ msg "Can not detect current firmware type" ; exit_init ; }
	fi

	rm /tmp/uboot_partimg /tmp/uboot_partimg_strings
}

initialize_gpio() {
# Description: Initialize GPIO for LEDs and SD card on T20 cameras
	[[ "chip_family" == "T20" ]] && initialize_t20_gpio_sdcard
	initialize_gpio_leds
}

welcome_msg() {
	msg "Welcome to $installer_name!"
}

wait_init_interrupt() {
	msg
	msg
	echo "Press any key to interrupt init" > /dev/console
	msg
	msg
	exec 0< /dev/console
	read -r -s -n 1 -t 3
	if [[ "$?" -eq 0 ]]; then
		echo "Dropping a shell"
		exec 1> /dev/console
		exec 2> /dev/console
		exec /bin/sh
	fi
	echo "Action has timed out" > /dev/console
}

import_config_vars() {
	[ ! -f $config_file ] && { msg "$config_file file is missing" ; mv /tmp/initramfs.log /tmp/initramfs_missing-config-file.log ; exit_init ; }

	dos2unix $config_file # Fix MS-DOS newline import issue
	source $config_file || { msg "$config_file file is invalid" ; exit_init ; }
	
	[[ ! "$restore_fw_type" == "stock" ]] || [[ ! "$restore_fw_type" == "openipc" ]] && { msg "Invalid restore firmware type" ; exit_init ; }
}

function do_backup_operations() {
# Description: Create partition images of flash partition. If current firmware stock, create extra backup for device-specific information on config and para partitions
	/blink_blue_led.sh &
	blue_led_pid="$!"
	msg
	msg "---------- Begin of backup operations ----------"
	backup_full_flash
	if [[ "$current_fw_type" == "stock" ]] && [[ "$chip_family" = "T20" ]]; then
		msg "Backing up stock partitions and config for T20 camera"
		mkdir -p $stock_backup_dir_path
		backup_t20_stock_parts
		backup_t20_stock_config
		backup_t20_stock_para
		
	elif [[ "$current_fw_type" == "stock" ]] && [[ "$chip_family" = "T31" ]]; then
		mkdir -p $stock_backup_dir_path
		msg "Backing up stock partitions and config for T31 camera"
		backup_t31_stock_parts
		backup_t31_stock_config
		
	elif [[ "$current_fw_type" == "openipc" ]]; then
		msg "Backing up OpenIPC partitions"
		mkdir -p $openipc_backup_dir_path
		backup_openipc_parts
		
	fi
	kill $red_led_pid
}

function do_restore_operations() {
# Description: Restore flash partitions using partion images
	[ ! -d $restore_dir_path ] && { msg "$restore_dir_path directory is missing" ; exit_init ; }

	cp -r $restore_dir_path /$restore_dir_name # Copy restore directory to RAM in case of defected SD card
	cd /$restore_dir_name

	/blink_red_led.sh &
	red_led_pid="$!"
	msg
	msg "---------- Begin of restore operations ----------"
	if [[ "$restore_fw_type" == "stock" ]] && [[ "$chip_family" = "T20" ]]; then
		msg "Restoring stock partitions for T20 camera"
		restore_t20_stock_parts
	elif [[ "$restore_fw_type" == "stock" ]] && [[ "$chip_family" = "T31" ]]; then
		msg "Restoring stock partitions for T31 camera"
		restore_t31_stock_parts
	elif [[ "$restore_fw_type" == "openipc" ]]; then
		msg "Restoring OpenIPC partitions for T20 camera"
		restore_openipc_parts
	fi
	kill $red_led_pid
}

function execute_custom_script() {
# Description: Execute user custom script
	msg "custom_script value is set to \"$custom_script\""
	
	if [ -f /sdcard/$custom_script ]; then
		if [[ "$dry_run" == "yes" ]]; then
			msg "Custom script does not run when dry mode is active"
		else
			msg "Executing custom script"
			/sdcard/$custom_script || { msg "Custom script did not run properly" ; exit_init ; }
		fi
	else
		msg "Custom script file is missing"
	fi
}

function main() {
	set_variables
	detect_chip_and_fw
	welcome_msg
	
	wait_init_interrupt
	import_config_vars
	
	if [[ "${backup_partitions}" == "yes" ]]; then
		{ msg "backup_partitions value is Yes" ; do_backup_operations ; }
	else
		msg "backup_partitions value is No"
	fi

	if [[ "$restore_partitions" == "yes" ]] && [[ "$switch_fw" == "yes" ]]; then
		{ echo "Restore and Switch_fw operations are conflicted, please enable only one" ; exit_init ; }
	fi

	if [[ "$restore_partitions" == "yes" ]]; then
		msg "restore_partitions value is Yes"
		do_restore_operations
	else
		msg "restore_partitions value is No"
	fi
	
	if [[ "$switch_fw" == "yes" ]]; then
		msg "switch_fw value is Yes"
		do_switch_fw_operations
	else
		msg "switch_fw value is No"
	if

	if [[ "$enable_custom_script" == "yes" ]]; then
		msg "enable_custom_script value is Yes"
		execute_custom_script
	else
		msg "enable_custom_script value is Yes"
	fi

	exit_init
}


main
