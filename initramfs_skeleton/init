#!/bin/sh
#
#                          ,---.,--.               ,--.            ,--.            ,--.                      
# ,--.   ,--.,-----.      /  .-'|  | ,--,--. ,---. |  ,---. ,-----.|  ,---.  ,---. |  | ,---.  ,---. ,--.--. 
# |  |.'.|  |`-.  /       |  `-,|  |' ,-.  |(  .-' |  .-.  |'-----'|  .-.  || .-. :|  || .-. || .-. :|  .--' 
# |   .'.   | /  `-.,----.|  .-'|  |\ '-'  |.-'  `)|  | |  |       |  | |  |\   --.|  || '-' '\   --.|  |    
# '--'   '--'`-----''----'`--'  `--' `--`--'`----' `--' `--'       `--' `--' `----'`--'|  |-'  `----'`--'    
#                                                                                     `--'                  
#

exec > /tmp/initramfs.log 2>&1
set -x

mount -t devtmpfs devtmpfs /dev
mount -t proc proc /proc
mount -t sysfs sysfs /sys

sleep 1

function msg() {
# Description: Allow output messages to be both displayed on the serial terminal and written to the log file
	message="$1"
	echo "$message"
	echo "$message" > /dev/console
	echo "$message" > /tmp/initramfs_serial.log
}

function msg_dry_run() {
# Description: Allow output messages to be both displayed on the serial terminal and written to the log file
	message="$1"
	echo " + (this command is not run) $message"
	echo " + (this command is not run) $message" > /dev/console
	echo " + (this command is not run) $message" > /tmp/initramfs_serial.log
}

function msg_nonewline() {
	message="$1"
	echo -n "$message"
	echo -n "$message" > /dev/console
	echo -n "$message" > /tmp/initramfs_serial.log
}

function initialize_t20_gpio_sdcard() {
# Description: T20 cameras need this to get SD card detected
	echo 43 > /sys/class/gpio/export
	echo in > /sys/class/gpio/gpio43/direction
	sleep 3 # Required delay interval for SD card init on T20
}

function initialize_gpio_leds() {
# Description: Export LEDs GPIO pins if they don't exist
	if [ ! -d /sys/class/gpio/gpio38 ]; then
		echo 38 > /sys/class/gpio/export
		echo out > /sys/class/gpio/gpio38/direction
		echo 1 > /sys/class/gpio/gpio38/value
	fi
	
	if [ ! -d /sys/class/gpio/gpio39 ]; then
		echo 39 > /sys/class/gpio/export
		echo out > /sys/class/gpio/gpio39/direction
		echo 1 > /sys/class/gpio/gpio39/value
	fi
}

function backup_partition_to_file() {
# Description: Backup partition <partmtd> to <outfile>
# Syntax: backup_partition_to_file <partname> <partmtd> <outfile>
	local partname="$1"
	local partmtd="$2"
	local outfile="$3"
	
	[ -f $outfile ] && { msg " + $outfile exists" ; return 1 ; }
	
	if [[ "$dry_run" == "yes" ]]; then
		msg_dry_run "dd if=$partmtd of=$outfile"
		msg_dry_run "md5sum $outfile > $outfile.md5sum"
	else
		dd if=$partmtd of=$outfile || { msg " + Failed to backup $partname partition" ; return 1 ; }
		md5sum $outfile > $outfile.md5sum
	fi
}

function restore_file_to_partition() {
# Description: Restore partition from <infile> to <partmtd>
# Syntax: restore_file_to_partition <partname> <infile> <partname>
	local partname="$1"
	local infile="$2"
	local partmtd="$3"
	
	[ ! -f $infile ] && { msg " + $infile is missing" ; return 1 ; }
	
	msg_nonewline " + Checking md5 of $infile: "
	if [[ "$dry_run" == "yes" ]]; then
		md5sum -c $infile.md5sum && msg_dry_run "flash_eraseall $partmtd && flashcp $infile $partmtd"
	else
		md5sum -c $infile.md5sum && { flash_eraseall $partmtd ; flashcp $infile $partmtd ; } || { msg " + md5 checksum for $infile failed" ; return 1 ; }
	fi
}

function backup_stock_config_part_files_to_archive() {
# Description: Backup all files from a JFFS2 partition to .tar.gz file
# Syntax: backup_stock_config_part_files_to_archive <partname> <partblockmtd> <outfile>
	local partname="$1"
	local partblockmtd="$2"
	local outfile="$3"
	
	local outfile=$stock_backup_dir_path/config.tar.gz
	msg "- Backup: $partname partition files to file $outfile ---"
	
	mkdir -p /$partname-stock_config
	mount -t jffs2 $partblockmtd /$partname-stock_config_path || { msg "Mount $partname partition failed" ; exit_init ; }
	if [[ "$dry_run" == "yes" ]]; then
		msg_dry_run "tar -cvf $outfile /$partname-stock_config"
	else
		tar -cvf $outfile /$partname-stock_config
	fi
	sync
	umount /$partname-stock_config && rmdir /$partname-stock_config
}

#    ____             _                   __                  _   _                 
#   | __ )  __ _  ___| | ___   _ _ __    / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
#   |  _ \ / _` |/ __| |/ / | | | '_ \  | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
#   | |_) | (_| | (__|   <| |_| | |_) | |  _| |_| | | | | (__| |_| | (_) | | | \__ \
#   |____/ \__,_|\___|_|\_\\__,_| .__/  |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
#                               |_|                                                 

function backup_full_flash() {
# Description: Backup the whole flash to a file
	if [[ "$current_fw_type" == "stock" ]] && [[ "$chip_family" == "t20" ]]; then
		full_flash_backup_file=$stock_backup_dir_path/$t20_stock_full_flash_filename
	elif [[ "$current_fw_type" == "stock" ]] && [[ "$chip_family" == "t31" ]]; then
		full_flash_backup_file=$stock_backup_dir_path/$t31_stock_full_flash_filename
	elif [[ "$current_fw_type" == "openipc" ]]; then
		full_flash_backup_file=$openipc_backup_dir_path/$openipc_full_flash_filename
	fi
	
	local partname="all_flash"
	local partmtd="$concat_partmtd"
	local outfile="$full_flash_backup_file"
	
	backup_partition_to_file $partname $partmtd $outfile
}

function backup_t20_stock_parts() {
# Description: Create partition images of all stock partitions on T20 flash chip
	msg "Backing up T20 stock partitions"
	
	for partname in $t20_stock_backup_partname_list; do
		local partmtd=$(get_t20_stock_partmtd $partname)
		local outfile_name=$(get_t20_stock_partimg $partname)
		local outfile=$stock_backup_dir_path/$outfile_name
		msg "- Backup: $partname to file $outfile ---"
		backup_partition_to_file $partname $partmtd $outfile || { msg "Backup $partname partition to $outfile failed" ; exit_init ; }
	done
}

function backup_t20_stock_config() {
# Description: Create .tar.gz archive for config partition files on T20 flash chip
	local partname="config"
	local partmtdblock="$config_t20_stock_partmtdblock"
	local outfile=$stock_backup_dir_path/$partname.tar.gz
	
	backup_stock_config_part_files_to_archive $partname $partmtdblock $outfile
}

function backup_t20_stock_para() {
# Description: Create .tar.gz archive for para partition files on T20 flash chip
	local partname="para"
	local partmtdblock="$para_t20_stock_partmtdblock"
	local outfile=$stock_backup_dir_path/$partname.tar.gz
	
	backup_stock_config_part_files_to_archive $partname $partmtdblock $outfile
}

function backup_t31_stock_parts() {
# Description: Create partition images of all stock partitions on T31 flash chip
	msg "Backing up T31 stock partitions"
	
	for partname in $t31_stock_backup_partname_list; do
		local partmtd=$(get_t31_stock_partmtd $partname)
		local outfile_name=$(get_t31_stock_partimg $partname)
		local outfile=$stock_backup_dir_path/$outfile_name
		msg "- Backup: $partname to file $outfile ---"
		backup_partition_to_file $partname $partmtd $outfile || { msg "Backup $partname partition to $outfile failed" ; exit_init ; }
	done
}

function backup_t31_stock_config() {
# Description: Create .tar.gz archive for config partition files on T31 flash chip
	local partname="cfg"
	local partmtdblock="$config_t31_stock_partmtdblock"
	local outfile=$stock_backup_dir_path/$partname.tar.gz
	
	backup_stock_config_part_files_to_archive $partname $partmtdblock $outfile
}

function backup_openipc_parts() {
# Description: Create partition images of all OpenIPC partitions on T31 flash chip
	msg "Backing up OpenIPC partitions"
	
	for partname in $openipc_backup_partname_list; do
		local partmtd=$(get_openipc_partmtd $partname)
		local outfile_name=$(get_openipc_partimg $partname)
		local outfile=$openipc_backup_dir_path/$outfile_name
		
		msg "- Backup: $partname to file $outfile ---"
		backup_partition_to_file $partname $partmtd $outfile || { msg "Backup $partname partition to $outfile failed" ; exit_init ; }
	done
}


#    ____           _                    __                  _   _                 
#   |  _ \ ___  ___| |_ ___  _ __ ___   / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
#   | |_) / _ \/ __| __/ _ \| '__/ _ \ | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
#   |  _ <  __/\__ \ || (_) | | |  __/ |  _| |_| | | | | (__| |_| | (_) | | | \__ \
#   |_| \_\___||___/\__\___/|_|  \___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
#
                                                                       
function restore_t20_stock_parts() {
# Description: Restore stock partitions from partition images on T20 flash chip
	msg "Restoring T20 stock partitions"
	
	for partname in $t20_stock_restore_partname_list; do
		local infile_name=$(get_t20_stock_partimg $partname)
		local infile=$stock_restore_dir_path/$infile_name
		local partmtd=$(get_t20_stock_partmtd $partname)
		local restore_opt_value=$(get_t20_stock_restore_opt_value $partname)
		
		msg "- Restore: $partname from file $infile"
		if [[ "$restore_opt_value" == "yes" ]]; then
			msg " + t20_restore_$partname value is Yes"
			restore_file_to_partition $partname $infile $partmtd || { msg "Restore $infile to $partname partition failed" ; exit_init ; }
		else
			msg " + t20_restore_$partname value is No"
		fi
	done
}

function restore_t31_stock_parts() {
# Description: Restore stock partitions from partition images on T31 flash chip
	msg "Restoring T31 stock partitions"
	
	for partname in $t31_stock_restore_partname_list; do
		local infile_name=$(get_t31_stock_partimg $partname)
		local infile=$stock_restore_dir_path/$infile_name
		local partmtd=$(get_t31_stock_partmtd $partname)
		local restore_opt_value=$(get_t31_stock_restore_opt_value $partname)
		
		msg "- Restore: $partname from file $infile"
		if [[ "$restore_opt_value" == "yes" ]]; then
			msg " + t31_restore_$partname value is Yes"
			restore_file_to_partition $partname $infile $partmtd || { msg "Restore $infile to $partname partition failed" ; exit_init ; }
		else
			msg " + t31_restore_$partname value is No"
		fi
	done
}

function restore_openipc_parts() {
# Description: Restore OpenIPC partitions from partition images on T20 flash chip
	msg "Restoring OpenIPC partitions"
	
	for partname in $openipc_restore_partname_list; do
		local infile_name=$(get_openipc_partimg $partname)
		local infile=$openipc_restore_dir_path/$infile_name
		local partmtd=$(get_openipc_partmtd $partname)
		local restore_opt_value=$(get_openipc_restore_opt_value $partname)
		
		msg "- Restore: $partname from file $infile"
		if [[ "$restore_opt_value" == "yes" ]]; then
			msg " + openipc_restore_$partname value is Yes"
			restore_file_to_partition $partname $infile $partmtd || { msg "Restore $infile to $partname partition failed" ; exit_init ; }
		else
			msg " + openipc_restore_$partname value is No"
		fi
	done
}


#    ____          _ _       _        __             __                  _   _                 
#   / ___|_      _(_) |_ ___| |__    / _|_      __  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
#   \___ \ \ /\ / / | __/ __| '_ \  | |_\ \ /\ / / | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
#    ___) \ V  V /| | || (__| | | | |  _|\ V  V /  |  _| |_| | | | | (__| |_| | (_) | | | \__ \
#   |____/ \_/\_/ |_|\__\___|_| |_| |_|   \_/\_/   |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
#
                                                                                            
function switch_fw_stock_to_openipc() {
	cp -r $stock_switch_fw_dir_path /switch_fw_stock_to_openipc
	cd /switch_fw_stock_to_openipc
	
	for partname in $openipc_backup_partname_list; do
		md5sum -c $partname.md5sum || { msg "Failed to verify $partname partition image, aborting firmware switch" ; return 1 ; }
	done
	
	for partname in $openipc_backup_partname_list; do
		local infile=$(get_openipc_partimg $partname)
		local partmtd=$(get_openipc_partmtd $partname)
		restore_file_to_partition $partname $infile $partmtd || { msg "Failed to write $partname partition image, aborting firmware switch" ; return 1 ; }
	done
	rm -r switch_fw_stock_to_openipc
}

function switch_fw_openipc_to_t20_stock() {
	cp -r $openipc_switch_fw_dir_path /switch_fw_openipc_to_t20_stock
	cd /switch_fw_openipc_to_t20_stock
	
	for partname in $t20_stock_backup_partname_list; do
		md5sum -c $partname.md5sum || { msg "Failed to verify $partname partition image, aborting firmware switch" ; return 1 ; }
	done
	
	for partname in $t20_stock_backup_partname_list; do
		local infile=$(get_t20_stock_partimg $partname)
		local partmtd=$(get_t20_stock_partmtd $partname)
		restore_file_to_partition $partname $infile $partmtd || { msg "Failed to write $partname partition image, aborting firmware switch" ; return 1 ; }
	done
	rm -r /switch_fw_openipc_to_t20_stock
}

function switch_fw_openipc_to_t31_stock() {
	cp -r $openipc_switch_fw_dir_path /switch_fw_openipc_to_t31_stock
	cd /switch_fw_openipc_to_t31_stock
	
	for partname in $t31_stock_backup_partname_list; do
		md5sum -c $partname.md5sum || { msg "Failed to verify $partname partition image, aborting firmware switch" ; return 1 ; }
	done
	
	for partname in $t31_stock_backup_partname_list; do
		local infile=$(get_t31_stock_partimg $partname)
		local partmtd=$(get_t31_stock_partmtd $partname)
		restore_file_to_partition $partname $infile $partmtd || { msg "Failed to write $partname partition image, aborting firmware switch" ; return 1 ; }
	done
	rm -r /switch_fw_openipc_to_t31_stock
}


#   __  __ _             __                  _   _                 
#  |  \/  (_)___  ___   / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
#  | |\/| | / __|/ __| | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
#  | |  | | \__ \ (__  |  _| |_| | | | | (__| |_| | (_) | | | \__ \
#  |_|  |_|_|___/\___| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
#                                                                 

function move_continue_boot_img_file() {
# Description: Remane SD card boot image to be booted next boot
	if [[ "$enable_continue_boot_img" == "yes" ]]; then
		msg "enable_continue_boot_img value is Yes"
		case "$current_fw_type" in
			"stock")
				msg "Renaming /sdcard/$continue_boot_img_filename to /sdcard/factory_t31_ZMC6tiIDQN"
				mv /sdcard/$continue_boot_img_filename /sdcard/factory_t31_ZMC6tiIDQN
				;;
			"openipc")
				msg "Renaming /sdcard/$continue_boot_img_filename to /sdcard/factory_0P3N1PC_kernel"
				mv /sdcard/$continue_boot_img_filename /sdcard/factory_0P3N1PC_kernel
				;;
		esac
	else
		msg "enable_continue_boot_img value is No"
	fi
}

function move_flash_tool_boot_img_file() {
# Description: Rename the SD card boot image to avoid infinite boot loop
	case "$current_fw_type" in
		"stock")
			msg "Renaming /sdcard/factory_t31_ZMC6tiIDQN to /sdcard/factory_t31_ZMC6tiIDQN.$flash_tool_name"
			mv /sdcard/factory_t31_ZMC6tiIDQN /sdcard/factory_t31_ZMC6tiIDQN.$flash_tool_name
			;;
		"openipc")
			msg "Renaming /sdcard/factory_0P3N1PC_kernel to /sdcard/factory_0P3N1PC_kernel.$flash_tool_name"
			mv /sdcard/factory_0P3N1PC_kernel /sdcard/factory_0P3N1PC_kernel.$flash_tool_name
			;;
	esac
}


#   __  __       _          __                  _   _                 
#  |  \/  | __ _(_)_ __    / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
#  | |\/| |/ _` | | '_ \  | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
#  | |  | | (_| | | | | | |  _| |_| | | | | (__| |_| | (_) | | | \__ \
#  |_|  |_|\__,_|_|_| |_| |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
#

function initialize_gpio() {
# Description: Initialize GPIO for LEDs and SD card on T20 cameras
	[[ "chip_family" == "t20" ]] && initialize_t20_gpio_sdcard
	initialize_gpio_leds
}

function welcome_msg() {
	msg "Welcome to $flash_tool_name!"
}

function wait_init_interrupt() {
# Description: Allow user to access initramfs shell
	msg
	msg
	echo "Press any key to interrupt init" > /dev/console
	
	exec 0< /dev/console
	read -r -s -n 1 -t 3
	if [[ "$?" -eq 0 ]]; then
		echo "Dropping a shell"
		exec 1> /dev/console
		exec 2> /dev/console
		exec /bin/sh
	fi
	echo "Action has timed out" > /dev/console
	msg
	msg
}

function import_init_variables() {
	source /init_variables.sh
}

function detect_chip_and_fw() {
# Description: Detect chip family and current firmware to do later operations correctly
	chip_name=`ipcinfo-mips32 --chip-name`
	chip_family=`ipcinfo-mips32 --family`
	msg "Detected chip name: $chip_name, chip family: $chip_family"
	
	dd if=$boot_partmtd of=/tmp/boot_partimg
	strings /tmp/boot_partimg > /tmp/boot_partimg_strings
	
	if grep -q "demo.bin" /tmp/boot_partimg_strings ; then # Cam v2 & Cam Pan
		msg "Camera is currently on Cam Pan v2 or Cam Pan stock firmware"
		current_fw_type="stock"
	
	elif grep -q "demo_wcv3.bin" /tmp/boot_partimg_strings ; then # Cam v3
		msg "Camera is currently on Cam v3 stock firmware"
		current_fw_type="stock"
	
	elif grep -q "recovery_wcpv2.bin" /tmp/boot_partimg_strings ; then # Cam Pan v2
		msg "Camera is currently on Cam Pan v2 stock firmware"
		current_fw_type="stock"
	
	elif grep -q "factory_0P3N1PC_kernel" /tmp/boot_partimg_strings ; then
		msg "Camera is currently on OpenIPC firmware"
		current_fw_type="openipc"
	
	else
		{ msg "Can not detect current firmware type" ; exit_init ; }
	fi
	
	rm /tmp/boot_partimg /tmp/boot_partimg_strings
}

function import_partmtd_info() {
	source /init_partmtd_info.sh
}

function import_config_file_vars() {
# Description: Import wz_flasher-helper.conf from SD card
	[ ! -f $config_file ] && { msg "$config_file file is missing" ; mv /tmp/initramfs.log /tmp/initramfs_missing-config-file.log ; exit_init ; }
	
	dos2unix $config_file # Fix MS-DOS newline import issue
	source $config_file || { msg "$config_file file is invalid" ; exit_init ; }
}

function mount_sdcard() {
	msg "Mounting SD card"
	mkdir -p /sdcard
	mount -t vfat /dev/mmcblk0p1 /sdcard -o rw,umask=0000,dmask=0000
}

function do_backup_operation() {
# Description: Create partition images of flash partition. If current firmware stock, create extra backup for device-specific information on config and para partitions
	/blink_blue_led.sh &
	blue_led_pid="$!"
	msg
	msg "---------- Begin of backup operation ----------"
	backup_full_flash
	if [[ "$current_fw_type" == "stock" ]] && [[ "$chip_family" = "t20" ]]; then
		msg "Backing up stock partitions and config for T20 camera"
		mkdir -p $stock_backup_dir_path
		backup_t20_stock_parts
		backup_t20_stock_config
		backup_t20_stock_para
		
	elif [[ "$current_fw_type" == "stock" ]] && [[ "$chip_family" = "t31" ]]; then
		mkdir -p $stock_backup_dir_path
		backup_t31_stock_parts
		backup_t31_stock_config
		
	elif [[ "$current_fw_type" == "openipc" ]]; then
		msg "Backing up OpenIPC partitions"
		mkdir -p $openipc_backup_dir_path
		backup_openipc_parts
		
	fi
	kill $red_led_pid
}

function do_restore_operation() {
# Description: Restore flash partitions using partion images
	case "$current_fw_type" in
		"stock") restore_dir_path="$stock_restore_dir_path" ;;
		"openipc") restore_dir_path="$stock_restore_dir_path" ;;
	esac
	
	[ ! -d $restore_dir_path ] && { msg "$restore_dir_path directory is missing" ; exit_init ; }
	
	cp -r $restore_dir_path /$restore_dir_name # Copy the restore directory to RAM in case of defective SD card
	cd /$restore_dir_name
	
	/blink_red_led.sh &
	red_led_pid="$!"
	msg
	msg "---------- Begin of restore operation ----------"
	if [[ "$restore_fw_type" == "stock" ]] && [[ "$chip_family" = "t20" ]]; then
		msg "Restoring stock partitions for T20 camera"
		restore_t20_stock_parts
	elif [[ "$restore_fw_type" == "stock" ]] && [[ "$chip_family" = "t31" ]]; then
		msg "Restoring stock partitions for T31 camera"
		restore_t31_stock_parts
	elif [[ "$restore_fw_type" == "openipc" ]]; then
		msg "Restoring OpenIPC partitions for T20 camera"
		restore_openipc_parts
	fi
	kill $red_led_pid
	rm -r /$restore_dir_name
}

function do_switch_fw_operation() {
# Description: Switch firmware by flashing all needed partitions
	if [[ "$current_fw_type" == "$switch_fw_to" ]]; then
		{ msg "switch_fw_to value is same as current firmware type, aborting firmware switch" ; exit_init ; }
	fi
	
	/blink_red_and_blue_leds.sh &
	red_and_blue_leds_pid="$!"
	if [[ "$current_fw_type" == "stock" ]] && [[ "$switch_fw_to" == "openipc" ]]; then
		msg "Switching from stock firmware to OpenIPC"
		switch_fw_stock_to_openipc
	
	elif [[ "$current_fw_type" == "stock" ]] && [[ "$switch_fw_to" == "stock" ]] && [[ "$chip_family" == "t20" ]]; then
		msg "Switching from OpenIPC firmware to T20 stock"
		switch_fw_openipc_to_t20_stock
	
	elif [[ "$current_fw_type" == "stock" ]] && [[ "$switch_fw_to" == "stock" ]] && [[ "$chip_family" == "t31" ]]; then
		msg "Switching from OpenIPC firmware to T31 stock"
		switch_fw_openipc_to_t31_stock
	
	fi
	kill $red_and_blue_leds_pid
}

function execute_custom_script() {
# Description: Execute user custom script
	msg "custom_script value is set to \"$custom_script\""
	
	if [ -f /sdcard/$custom_script ]; then
		if [[ "$dry_run" == "yes" ]]; then
			msg "Custom script does not run when dry mode is active"
		else
			msg "Executing custom script"
			/sdcard/$custom_script || { msg "Custom script did not run properly" ; exit_init ; }
		fi
	else
		msg "Custom script file is missing"
	fi
}

function exit_init() {
# Description: Move initramfs log to SD card and reboot
	msg "---------- Exit init ----------"
	move_continue_boot_img_file
	move_flash_tool_boot_img_file
	msg "Initramfs init is finished! Exiting now"
	[ -f /tmp/initramfs.log ] && cp /tmp/initramfs.log $log_file
	[ -f /tmp/initramfs_serial.log ] && cp /tmp/initramfs_serial.log $log_file_serial
	[ -f /tmp/initramfs_missing-config-file.log ] && cp /tmp/initramfs_missing-config-file.log $log_file_fallback
	sync
	umount /sdcard
	sleep 1
	reboot
}

function main() {
	initialize_gpio
	import_init_variables
	welcome_msg
	
	wait_init_interrupt
	
	mount_sdcard
	import_partmtd_info
	import_config_file_vars
	
	
	detect_chip_and_fw
	
	if [[ "$backup_partitions" == "yes" ]]; then
		{ msg "backup_partitions value is Yes" ; do_backup_operation ; }
	else
		msg "backup_partitions value is No"
	fi
	
	if [[ "$restore_partitions" == "yes" ]] && [[ "$switch_fw" == "yes" ]]; then
		{ msg "Restore and Switch_fw operation are conflicted, please enable only one option at a time" ; exit_init ; }
	fi
	msg
	msg
	if [[ "$restore_partitions" == "yes" ]]; then
		msg "restore_partitions value is Yes"
		do_restore_operation
	else
		msg "restore_partitions value is No"
	fi
	msg
	msg
	if [[ "$switch_fw" == "yes" ]]; then
		msg "switch_fw value is Yes"
		do_switch_fw_operation
	else
		msg "switch_fw value is No"
	fi
	msg
	msg
	if [[ "$enable_custom_script" == "yes" ]]; then
		msg "enable_custom_script value is Yes"
		execute_custom_script
	else
		msg "enable_custom_script value is Yes"
	fi
	msg
	msg
	exit_init
}


main
