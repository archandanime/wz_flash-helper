#!/bin/sh
#
#                          ,---.,--.               ,--.            ,--.            ,--.                      
# ,--.   ,--.,-----.      /  .-'|  | ,--,--. ,---. |  ,---.        |  ,---.  ,---. |  | ,---.  ,---. ,--.--. 
# |  |.'.|  |`-.  /       |  `-,|  |' ,-.  |(  .-' |  .-.  |,-----.|  .-.  || .-. :|  || .-. || .-. :|  .--' 
# |   .'.   | /  `-.,----.|  .-'|  |\ '-'  |.-'  `)|  | |  |'-----'|  | |  |\   --.|  || '-' '\   --.|  |    
# '--'   '--'`-----''----'`--'  `--' `--`--'`----' `--' `--'       `--' `--' `----'`--'|  |-'  `----'`--'    
#                                                                                     `--'                  



exec > /tmp/initramfs.log 2>&1
set -x

mount -t devtmpfs devtmpfs /dev
mount -t proc proc /proc
mount -t sysfs sysfs /sys

sleep 1

function msg() {
# Description: Allow output messages to be both displayed on the serial terminal and written to the log files
	local message="$1"

	echo "$message" # Print to log file
	echo "$message" > /dev/console # Print on serial terminal
	echo "$message" >> /tmp/initramfs_serial.log # Print to an extra log file, it is exactly the same as on serial terminal
}

function msg_dry_run() {
# Description: Print out commands instead of executing them when dry run is enabled
	local cmd="$1"

	echo " + (this command is not run) $cmd"
	echo " + (this command is not run) $cmd" > /dev/console
	echo " + (this command is not run) $cmd" >> /tmp/initramfs_serial.log
}

function msg_nonewline() {
# Description: Same as msg but without newline
	local message="$1"

	echo -n "$message"
	echo -n "$message" > /dev/console
	echo -n "$message" >> /tmp/initramfs_serial.log
}

function detect_chip_and_fw() {
# Description: Detect chip family and current firmware to run later operations correctly
	chip_name=$(ipcinfo-mips32 --chip-name)
	chip_family=$(ipcinfo-mips32 --family)
	msg "Detected chip name: $chip_name, chip family: $chip_family"

	dd if=/dev/mtd0 of=/boot_backup.img
	strings /boot_backup.img > /boot_backup_strings.txt

	if grep -q "demo.bin" /boot_backup_strings.txt ; then # Cam v2 & Cam Pan
		msg "Camera is currently on Cam Pan v2 or Cam Pan stock firmware"
		current_fw="stock"
	
	elif grep -q "demo_wcv3.bin" /boot_backup_strings.txt ; then # Cam v3
		msg "Camera is currently on Cam v3 stock firmware"
		current_fw="stock"
	
	elif grep -q "recovery_wcpv2.bin" /boot_backup_strings.txt ; then # Cam Pan v2
		msg "Camera is currently on Cam Pan v2 stock firmware"
		current_fw="stock"
	
	elif grep -q "factory_0P3N1PC_kernel" /boot_backup_strings.txt ; then
		msg "Camera is currently on OpenIPC firmware"
		current_fw="openipc"
	
	fi

	rm /boot_backup_strings.txt
}

function import_functions_and_variables() {
# Description: Set needed files and paths variables for this program, source functions for later operations and set extra variables based on detected current system info
	prog_name="wz_flash-helper"
	
	prog_dir="/sdcard/wz_flash-helper"
	
	prog_config_file="/sdcard/wz_flash-helper/wz_flash-helper.conf"
	prog_log_file="/sdcard/wz_flash-helper/wz_flash-helper.log"
	prog_log_file_serial="/sdcard/wz_flash-helper/wz_flash-helper_serial.log"
	
	concat_partmtd="/dev/mtd21"

	source /init_msg_main.sh
	source /init_functions_io.sh
	source /init_fw_info_openipc.sh
	
	case "$chip_family" in
		"t20")
			source /init_fw_info_t20_stock.sh ;;
		"t31")
			source /init_fw_info_t31_stock.sh ;;
	esac

	if [[ "$chip_family" == "t20" ]] && [[ "$current_fw" == "stock" ]]; then
		sdcard_boot_img_name="factory_ZMC6tiIDQN"
		
	elif [[ "$chip_family" == "t31" ]] && [[ "$current_fw" == "stock" ]]; then
		sdcard_boot_img_name="factory_t31_ZMC6tiIDQN"
	
	elif [[ "$current_fw" == "openipc" ]]; then
		sdcard_boot_img_name="factory_0P3N1PC_kernel"
	
	fi

}

function initialize_gpio() {
# Description: Initialize GPIO for LEDs and SD card on T20 cameras
	msg "Exporting GPIO pins for LEDs"
	if [ ! -d /sys/class/gpio/gpio38 ]; then # Export LEDs GPIO pins if they don't exist to enable LEDs
		echo 38 > /sys/class/gpio/export
		echo out > /sys/class/gpio/gpio38/direction
		echo 1 > /sys/class/gpio/gpio38/value
	fi
	
	if [ ! -d /sys/class/gpio/gpio39 ]; then
		echo 39 > /sys/class/gpio/export
		echo out > /sys/class/gpio/gpio39/direction
		echo 1 > /sys/class/gpio/gpio39/value
	fi

	if [[ "$chip_family" == "t20" ]]; then # T20 cameras need this to get SD card detected
		msg "Exporting GPIO pin to detect SD card on T20 cameras"
		echo 43 > /sys/class/gpio/export
		echo in > /sys/class/gpio/gpio43/direction
		sleep 3 # Required delay interval for SD card init on T20 cameras
	fi
}

function welcome_msg() {
# Description: It is nice to let the user know that they are welcome!
	msg
	msg "Welcome to $prog_name init!"
	msg
}

function wait_init_interrupt() {
# Description: Allow the user to access initramfs shell with serial connection
	msg
	echo "Press any key to interrupt init" > /dev/console
	
	exec 0< /dev/console
	read -r -s -n 1 -t 3
	if [[ "$?" -eq 0 ]]; then
		msg "Dropping a shell"
		msg "You can read /tmp/initramfs.log to see previously run commands"
		exec 1> /dev/console
		exec 2> /dev/console
		exec /bin/sh
	fi
	echo "Action has timed out" > /dev/console
	msg
}

function mount_sdcard() {
# Description: Mount SD card, nothing more
	msg_nonewline "Mounting SD card... "
	mkdir -p /sdcard
	mount -t vfat /dev/mmcblk0p1 /sdcard -o rw,umask=0000,dmask=0000 && msg "succeeded" || msg "failed"
}

function import_config_file() {
# Description: Source program config file to know and do what the user wants
	[ ! -d $prog_dir ] && { msg "$prog_dir does not exist. Creating it to store log files. Nothing will be done" ; mkdir -p $prog_dir ; exit_init ; }
	[ ! -f $prog_config_file ] && { msg "$prog_config_file file is missing. Nothing will be done" ; exit_init ; }

	# Fix issue that config file failed to be sourced if it contains MS-DOS newline
	dos2unix $prog_config_file && source $prog_config_file || { msg "$prog_config_file file is invalid. Nothing will be done" ; exit_init ; }
}

function exit_init() {
# Description: Rename SD card boot image to avoid infinite boot loop
	msg
	msg "---------- Exit init ----------"
	msg
	msg "Renaming /sdcard/$sdcard_boot_img_name to /sdcard/$sdcard_boot_img_name.$prog_name"
	mv /sdcard/$sdcard_boot_img_name /sdcard/$sdcard_boot_img_name.$prog_name

	msg "Initramfs init is finished! Exiting now"

	cp /tmp/initramfs.log $prog_log_file
	cp /tmp/initramfs_serial.log $prog_log_file_serial

	sync
	umount /sdcard

	sleep 1
	exit # Crash init to reboot immediately
	sleep 10 # This prevents init from continuing after exit_init is finished but the camera has not rebooted immediately
}

function main() {
	detect_chip_and_fw
	import_functions_and_variables
	initialize_gpio

	welcome_msg
	
	wait_init_interrupt
	
	mount_sdcard
	import_config_file

	[[ "$dry_run" == "yes" ]] && msg "$dry_run_yes" || msg "$dry_run_no"

	#---------- Backup operation ----------
	if [[ "$backup_partitions" == "yes" ]]; then
		msg "$backup_partitions_yes"
		source /init_operation_backup.sh || { msg "$backup_partitions_fail" ; exit_init ; }
	else
		msg "$backup_partitions_no"
	fi

	#---------- Restore operation ----------
	if [[ "$restore_partitions" == "yes" ]]; then
		msg "$restore_partitions_yes"
		source /init_operation_restore.sh || { msg "$restore_partitions_fail" ; exit_init ; }
	else
		msg "$restore_partitions_no"
	fi

	#---------- Switch fw operation ----------
	if [[ "$switch_fw" == "yes" ]]; then
		msg "$switch_fw_yes"
		source /init_operation_switch_fw.sh || { msg "$switch_fw_fail" ; exit_init ; }
	else
		msg "$switch_fw_no"
	fi

	#---------- Custom script ----------
	if [[ "$enable_custom_script" == "yes" ]]; then
		msg "$enable_custom_script_yes"
		source /init_action_execute_custom_script.sh || { msg "$enable_custom_script_fail" ; exit_init ; }
	else
		msg "$enable_custom_script_no"
	fi

	#---------- Continue boot image ----------
	if [[ "$enable_continue_boot_img" == "yes" ]]; then
		msg "$enable_continue_boot_img_yes"
		source /init_action_move_continue_boot_img_file.sh
	else
		msg "$enable_continue_boot_img_no"
	fi

	exit_init
}


main
